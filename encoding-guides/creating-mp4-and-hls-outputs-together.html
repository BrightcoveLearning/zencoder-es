---
title: Guía de transmuxación En
description: 'este tema se explica la <strong>transmuxación</strong>, un proceso que permite codificar los vídeos en MP4 y luego volver a empaquetarlos como salidas HLS.'
parent: Encoding Guides
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">Descripción general</h2>

    <p>Con Zencoder puede codificar sus videos a MP4 y luego volver a empaquetarlos como salidas HLS, a través de un proceso que llamamos "transmuxing" (en lugar de transcodificación). Transmuxing volverá a empaquetar los videos MP4 existentes en los segmentos MPEG TS necesarios para HTTP Live Streaming (HLS), sin tener que volver a codificar los archivos de video. Usando salidas dependientes, puede crear sus archivos H.264 más los archivos segmentados, todo en un solo trabajo, produciendo una respuesta más rápida a un costo menor; las salidas transmuxed se cobran a 1/4 del costo de codificación. El trabajo resultante crea 6 salidas: 2 cobradas a la tarifa normal de su cuenta, 3 archivos transmuxed a 1/4 del costo de codificación y 1 lista de reproducción, que es gratuita.</p>

    <p>Para ello, creará un único trabajo con dos conjuntos principales de salidas (más las listas de reproducción). El primer conjunto de salidas serán archivos MP4 H.264/AAC normales con algunos ajustes especiales que les permitirán trabajar como archivos fuente para las salidas HLS. El segundo conjunto de salidas usará esos archivos MP4 como entradas de "fuente", transmuxando su contenido a salidas HLS. Dado que se trata de salidas dependientes, esperarán hasta que finalice su fuente correspondiente antes de programar su procesamiento.</p>

    <p>La parte clave del proceso es utilizar <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a>, una nueva opción en V2 de la API de Zencoder. La fuente le dice a una salida que use el archivo creado por otra salida en el trabajo para su procesamiento, en lugar del archivo de entrada. En esta situación, Zencoder creará archivos H.264 basados en el archivo de entrada a las tasas de bits solicitadas. Cuando finalice cada una de esas salidas, se creará una versión segmentada a partir de la salida.</p>

    <aside class="bcls-aside bcls-aside--information">Nota: No hay forma de garantizar que la reproducción sea fluida si <strong>Combine salidas de transmux y transcodificación en una lista de reproducción</strong>. Es recomendable que las copias tengan que codificarse de la misma manera.</aside>
  </section>
  <section class="bcls-section">
    <h2 id="h264_outputs">Las salidas H.264</h2>

    <p>Comenzaremos creando 2 archivos H.264, apuntando a tasas de bits altas y bajas.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "label": "low",
    "format": "mp4",
    "video_bitrate": 200,
    "decoder_bitrate_cap": 300,
    "decoder_buffer_size": 1200,
    "audio_sample_rate": 44100,
    "height": "288",
    "url": "s3://example-bucket/low.mp4",
    "h264_reference_frames": 1,
    "forced_keyframe_rate": "0.1",
    "audio_bitrate": 56,
    "decimate": 2
},
{
    "label": "high",
    "format": "mp4",
    "video_bitrate": 1000,
    "decoder_bitrate_cap": 1500,
    "decoder_buffer_size": 6000,
    "audio_sample_rate": 44100,
    "height": "432",
    "url": "s3://example-bucket/high.mp4",
    "h264_reference_frames": "auto",
    "h264_profile": "main",
    "forced_keyframe_rate": "0.1",
    "audio_bitrate": 56
}</code></pre>

    <p>Los archivos resultantes de estas salidas se pueden reproducir en una amplia variedad de dispositivos. Cada uno tiene como objetivo una velocidad de bits y una resolución diferentes, por lo que los usuarios pueden recibir el archivo apropiado. Cada uno también es apropiado para segmentar para HTTP Live Streaming y servir como un flujo de velocidad de bits adaptable.</p>

    <p>Algunas opciones en la solicitud anterior para tener en cuenta:</p>

    <ul>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-frame-rate.html#forced-keyframe-rate"><code translate="No">forced_keyframe_rate</code></a> a 0,1. Esto obliga al video a tener un fotograma clave cada 10 segundos. Los archivos segmentados tendrán una duración de 10 segundos, por lo que esto asegurará que cada segmento comience con un fotograma clave.</li>
      <li><a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-bitrate-cap"><code translate="No">decoder_bitrate_cap</code></a> se establece en 1,5 veces la velocidad de bits objetivo del archivo. <a href="/encoding-settings/general-audio-video/encoding-settings-rate-control.html#decoder-buffer-size"><code translate="No">decoder_buffer_size</code></a> se establece en 3,5 veces a 5 veces la velocidad de bits objetivo del archivo. Esta configuración ayudará a mantener una tasa de bits constante en todo el archivo, de modo que los segmentos segmentados no varíen demasiado en tamaño y tasa de bits.</li>
    </ul>
    <p>Ahora que se han creado los archivos H.264, se pueden agregar salidas adicionales a la solicitud para crear archivos segmentados HTTP Live Streaming desde la fuente, sin necesidad de realizar una codificación adicional.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Segmented_Outputs">Salidas segmentadas</h2>

    <p>Cada una de las salidas de audio y video H.264 anteriores tiene <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#label"><code translate="No">labels</code></a> en sus opciones de API. Estas etiquetas se pueden utilizar junto con el <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a> opción para decirle a Zencoder que use el video creado por la salida con la etiqueta dada, en lugar del archivo de entrada. Dado que los archivos H.264 ya tienen una buena configuración para HLS, no es necesaria una codificación adicional.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "source": "low",
    "format": "ts",
    "copy_audio": "true",
    "copy_video": "true",
    "url": "s3://example-bucket/hls-low/hls-low.m3u8",
    "label": "hls-low",
    "type": "segmented"
}
{
    "source": "high",
    "format": "ts",
    "copy_audio": "true",
    "copy_video": "true",
    "url": "s3://example-bucket/hls-high/hls-high.m3u8",
    "label": "hls-high",
    "type": "segmented"
}
{
    "streams": [
    {
        "path": "hls-low/hls-low.m3u8",
        "bandwidth": 256
    },
    {
        "path": "hls-high/hls-high.m3u8",
        "bandwidth": 1056
    }
    ],
    "type": "playlist",
    "url": "s3://example-bucket/playlist.m3u8"
}</code></pre>

    <p>Los archivos resultantes de estas salidas son salidas segmentadas, dirigidas a diferentes anchos de banda, además de un archivo de lista de reproducción para que el dispositivo de reproducción conozca las transmisiones disponibles.</p>

    <p>Cada salida segmentada incluye el <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#source"><code translate="No">source</code></a> y especifica una de las salidas enumeradas anteriormente. También incluyen el <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-audio"><code translate="No">copy_audio</code></a> y <a href="/encoding-settings/general-audio-video/encoding-settings-transmuxing.html#copy-video"><code translate="No">copy_video</code></a> opciones, que le dicen a Zencoder que use las transmisiones de audio y video del archivo de origen y las vuelva a empaquetar en el nuevo contenedor, en lugar de transcodificarlas. Por último, los resultados también especifican un <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#type"><code translate="No">type</code></a> de segmentado y un <a href="/encoding-settings/formats-codecs/encoding-settings-format-and-codecs.html#format"><code translate="No">format</code></a> de ts, además de <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#url"><code translate="No">url</code></a> una extensión de.m3u8, para que Zencoder sepa crear archivos HLS segmentados.</p>

    <p>Finalmente, también se genera una lista de reproducción que hace referencia a cada una de las salidas segmentadas. Tenga en cuenta que el primer archivo al que se hace referencia en la lista de reproducción es el video de baja tasa de bits; el dispositivo que reproduce el video generalmente cargará la primera transmisión que aparece en la lista de reproducción inicialmente y cambiará a otras transmisiones según sea necesario. Esto significa que los primeros 10 segundos de reproducción utilizarán este flujo, después de lo cual el dispositivo tendrá suficiente información para seleccionar el flujo apropiado para reproducir.</p>

    <p><strong>NOTAS</strong></p>

    <ul>
      <li>La generación de listas de reproducción HLS actualmente no usa información de las otras salidas en el trabajo, pero es simplemente una forma de generar fácilmente una lista de reproducción con tasa de bits adaptativa formateada correctamente y cargarla junto con los otros archivos.</li>
      <li>Si bien los dispositivos iOS reproducirán la lista de reproducción de tasa de bits adaptativa creada, VLC no lo hará, debido a errores en el manejo de URL relativas. Buscará los archivos de segmento en el mismo directorio que el archivo de la lista de reproducción, en lugar del directorio del archivo de manifiesto.</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Full_request">Solicitud completa</h2>

    <p>Ahora que hemos repasado cada una de las principales secciones de salida, reunámoslo en una sola solicitud de API.</p>

    <pre class="line-numbers">
<code class="language-json" translate="No">{
    "input": "s3://zencodertesting/test.mov",
    "outputs": [
    {
        "label": "low",
        "format": "mp4",
        "video_bitrate": 200,
        "decoder_bitrate_cap": 300,
        "decoder_buffer_size": 1200,
        "audio_sample_rate": 44100,
        "height": "288",
        "url": "s3://example-bucket/low.mp4",
        "h264_reference_frames": 1,
        "forced_keyframe_rate": "0.1",
        "audio_bitrate": 56,
        "decimate": 2
    },
    {
        "label": "high",
        "format": "mp4",
        "video_bitrate": 1000,
        "decoder_bitrate_cap": 1500,
        "decoder_buffer_size": 6000,
        "audio_sample_rate": 44100,
        "height": "432",
        "url": "s3://example-bucket/high.mp4",
        "h264_reference_frames": "auto",
        "h264_profile": "main",
        "forced_keyframe_rate": "0.1",
        "audio_bitrate": 56
    },
    {
        "source": "low",
        "format": "ts",
        "copy_audio": "true",
        "copy_video": "true",
        "url": "s3://example-bucket/hls-low/hls-low.m3u8",
        "label": "hls-low",
        "type": "segmented"
    }
    {
        "source": "high",
        "format": "ts",
        "copy_audio": "true",
        "copy_video": "true",
        "url": "s3://example-bucket/hls-high/hls-high.m3u8",
        "label": "hls-high",
        "type": "segmented"
    }
    {
        "streams": [
        {
            "path": "hls-low/hls-low.m3u8",
            "bandwidth": 256
        },
        {
            "path": "hls-high/hls-high.m3u8",
            "bandwidth": 1056
        }
        ],
        "type": "playlist",
        "url": "s3://example-bucket/playlist.m3u8"
    }
    ]
}</code></pre>
  </section>
</article>