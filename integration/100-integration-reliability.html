---
title: Fiabilidad de integración del 100%
description: 'Este tema analiza los motivos por los que es posible que no pueda conectarse a Zencoder y cómo garantizar una integración confiable.'
parent: Integration
---
 <h1>{{ page.title }}</h1>
<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <section class="bcls-section">
    <h2 id="Overview">Descripción general</h2>

    <p>Zencoder es una dependencia de software esencial para la mayoría de nuestros clientes. Y aunque nuestro objetivo es lograr un tiempo de actividad del 100%, puede haber ocasiones en las que no pueda conectarse a Zencoder:</p>

    <p>Cuando esto sucede y Zencoder no funciona, tu aplicación suele recibir una' respuesta de servicio no disponible 503 de Zencoder, pero podría aparecer un error diferente (como un 500). Si has superado el límite de velocidad de la API, obtendrás una' respuesta superada del límite de tasa de 403.</p>

    <p>La buena noticia: dado que la codificación de video es un proceso asincrónico, puede crear su aplicación para que nunca experimente tiempo de inactividad o problemas relacionados con nuestra disponibilidad. Si hace esto, el peor de los casos es que sus trabajos tarden un poco más. Pero no se producen errores. Le recomendamos encarecidamente que haga esto.</p>

    <p>Para decirlo con más fuerza, <strong>si le preocupa la confiabilidad, debe seguir este enfoque de integración</strong> - para Zencoder, o para cualquier API crítica con la que se integre.</p>

    <ul>
      <li>Nuestro servicio puede verse afectado por problemas en un proveedor ascendente (por ejemplo, Amazon Web Services)</li>
      <li>Ocasionalmente necesitamos realizar un mantenimiento del sistema que requiere un tiempo de inactividad temporal.</li>
      <li>Has excedido tu <a href="/general-information/faq-rate-limiting.html">Límite de tasa de API</a></li>
      <li>etc.</li>
    </ul>
  </section>
  <section class="bcls-section">
    <h2 id="Reliable_app_integration">Integración confiable de aplicaciones</h2>

    <ol>
      <li>Incluir un <a href="/encoding-settings/general/encoding-settings-general-output-settings.html#secondary-url">URL secundaria</a> como copia de seguridad en caso de que falle la carga a su ubicación principal.</li>
      <li>Si obtiene un código de respuesta no exitoso de Zencoder, básicamente, algo que no sea 200 o 201, <strong>no falles en el trabajo</strong>. Un código de respuesta 503 no significa que su video no se pueda procesar. Simplemente significa que Zencoder no está disponible temporalmente.</li>
      <li>Si obtienes un <strong>error de conexión</strong> cuando intente conectarse a Zencoder, haga lo mismo.</li>
      <li>Similar, <strong>envuelve tus solicitudes de API en un tiempo de espera</strong>. Recomendamos un tiempo de espera de 30 segundos; Zencoder generalmente responde en menos de un segundo, por lo que 30 segundos suele ser mucho tiempo.</li>
      <li>En los tres casos, si obtiene un código de respuesta incorrecto, no puede conectarse o se agota el tiempo de espera de la solicitud de la API, <strong>marcar el trabajo como 'pendiente'.</strong></li>
      <li>Periódicamente <strong>reenvíe cualquier trabajo en el 'pendiente' </strong> estado . Podrías usar cron para hacer esto cada minuto, por ejemplo.</li>
    </ol>
    <p>Una vez que se vuelven a enviar los trabajos, todo se comporta con normalidad. De esta manera, un envío de trabajo fallido solo hace que el trabajo demore un poco más en lugar de causar problemas a su aplicación o sus usuarios.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Pseudocode">Pseudocódigo</h2>

    <p>Bien, esto no es Pseudocódigo, es Ruby. Pero Ruby es bastante fácil de leer.</p>

    <ol>
      <li>Imagine una tabla de videos que incluye estas columnas. (Obviamente tendrá más, incluidas columnas para almacenar una ID de trabajo de Zencoder y una ID de archivo de salida de Zencoder).
        <pre class="line-numbers">
<code class="language-ruby" translate="No">create_table :videos do |t|
t.string  :state
t.integer :lock_version
t.index   :state
end</code></pre>
      </li>
      <li>Un video debe incluir una máquina de estado con los siguientes estados:
        <ul>
          <li>pendiente (aún no enviado a Zencoder)</li>
          <li>sometiendo (actualmente enviando a Zencoder)</li>
          <li>transcodificación (enviado con éxito a Zencoder)</li>
          <li>terminado (Zencoder terminó la transcodificación y el trabajo está hecho)</li>
          <li>falló (Zencoder no pudo transcodificar el video)</li>
        </ul>
      </li>
      <li>Cuando se ingiera un nuevo vídeo, guarde el vídeo en el' estado de envío y active un trabajo en segundo plano para enviar el vídeo a Zencoder.
        <pre class="line-numbers">
<code class="language-ruby" translate="No"># got a new video!
video = Video.new(params)
video.state = "submitting"
video.save!
submit_to_zencoder(video)</code></pre>

        <p>Realmente debería poner en segundo plano el método submit_to_zencoder. En Ruby, usando DelayedJob, esto podría verse así:</p>

        <pre class="line-numbers">
<code class="language-ruby" translate="No">delay.submit_to_zencoder(video)</code></pre>

        <p>Pero nos quedaremos con nuestro <code translate="No">submit_to_zencoder(video)</code> método para fines de ejemplo.</p>
      </li>
      <li>La <code translate="No">submit_to_zencoder</code> La función se parece a esto. Esto debe ejecutarse de forma asincrónica, en segundo plano.
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def submit_to_zencoder(video)
begin
response = Zencoder::Job.create(attributes, :timeout =&gt; 30_000)
if response.code == 201
video.state = "transcoding"
else
video.state = "pending"
end

video.save!

# Rescue any connection error. Our plugin abstracts these as
# Zencoder::HTTPError.
#
# If you're not using the Zencoder plugin, this includes things
# like Errno::ECONNRESET, Errno::ETIMEDOUT, Errno::ECONNREFUSED,
# Errno::EHOSTDOWN, and SocketError.

rescue Timeout::Error, Zencoder::HTTPError
video.state = "pending"
video.save!
end
end</code></pre>
      </li>
      <li>De vez en cuando, por ejemplo, cada minuto, intente volver a enviar trabajos que estén en' estado «pendiente».
        <pre class="line-numbers">
<code class="language-ruby" translate="No">def resubmit_pending_jobs
Video.where(:state =&gt; "pending").find_each do |video|
begin
video.state = "submitting"
video.save!

submit_to_zencoder(video)
rescue ActiveRecord::StaleObjectError
end
end
end
</code></pre>

        <p>Además, al añadir una' columna «lock_version» a la tabla de vídeos, introducimos un bloqueo optimista. Esto significa que si el registro se actualiza entre la <code translate="No">Video.find</code> consulta y <code translate="No">video.save</code>, no enviará el trabajo a Zencoder. Esto evitará que el trabajo se envíe a Zencoder dos veces accidentalmente. Puede usar un bloqueo pesimista o de base de datos o algún otro método de bloqueo para lograr lo mismo.</p>

        <h2>Es fácil…</h2>

        <p>A fin de cuentas, este es un enfoque bastante simple para garantizar una confiabilidad de integración del 100% entre Zencoder y su aplicación. Son unos pocos pasos más que enviar ingenuamente un trabajo; pero garantiza que no importa lo que suceda, ya sea un tiempo de espera ocasional, un tiempo de inactividad inesperado en Zencoder o un mantenimiento programado, su aplicación se ejecuta de manera confiable.</p>
      </li>
    </ol>
  </section>
</article>